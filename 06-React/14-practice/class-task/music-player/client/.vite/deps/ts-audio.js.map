{
  "version": 3,
  "sources": ["../../node_modules/ts-audio/src/audio/utils.ts", "../../node_modules/ts-audio/src/audio/states.ts", "../../node_modules/ts-audio/src/EventEmitter.ts", "../../node_modules/ts-audio/src/audio/Audio.ts", "../../node_modules/ts-audio/src/audio/AudioCtx.ts", "../../node_modules/ts-audio/src/EventHandler.ts", "../../node_modules/ts-audio/src/audio/initializeSource.ts", "../../node_modules/ts-audio/src/audio/decodeAudioData.ts", "../../node_modules/ts-audio/src/playlist/states.ts", "../../node_modules/ts-audio/src/playlist/AudioPlaylist.ts", "../../node_modules/ts-audio/src/playlist/utils.ts", "../../node_modules/ts-audio/src/playlist/playAudio.ts", "../../node_modules/ts-audio/src/playlist/playNextAudio.ts", "../../node_modules/ts-audio/src/playlist/playPrevAudio.ts"],
  "sourcesContent": ["export const getBuffer = (file: string): Promise<ArrayBuffer> =>\n  fetch(file).then(response => {\n    if (!response.ok) {\n      throw new Error(`HTTP error, status = ${response.status}`);\n    }\n\n    return response.arrayBuffer();\n  });\n\nexport const throwsError = (value: string): void => {\n  throw new Error(`\\`ts-audio\\`: ${value}`);\n};\n\nexport const preloadFile = (\n  file: string,\n  attempts = 3,\n  done?: () => void\n): void => {\n  fetch(file)\n    .then(done)\n    .catch(() => {\n      if (!attempts) {\n        return;\n      }\n\n      preloadFile(file, attempts - 1);\n    });\n};\n", "export type StatesType = {\n  isDecoded: boolean;\n  isPlaying: boolean;\n  hasStarted: boolean;\n  source: AudioBufferSourceNode | null;\n  gainNode: GainNode | null;\n};\n\nconst states: StatesType = {\n  isDecoded: false,\n  isPlaying: false,\n  hasStarted: false,\n  source: null,\n  gainNode: null,\n};\n\nexport default states;\n", "export type EventType = {\n  data: unknown;\n};\n\nexport type EventEmitterType = {\n  listener: (keyEvent: string, callback: (param: EventType) => void) => void;\n  emit: (keyEvent: string, param: EventType) => void;\n};\n\nconst EventEmitter = (): EventEmitterType => {\n  const events: { [key: string]: (param: EventType) => void } = {};\n\n  return {\n    listener(keyEvent: string, callback: (param: EventType) => void) {\n      events[keyEvent] = callback;\n    },\n\n    emit(keyEvent: string, param: EventType) {\n      events[keyEvent]?.(param);\n    },\n  };\n};\n\nexport default EventEmitter;\n", "import AudioCtx from './AudioCtx';\nimport globalStates from './states';\nimport EventEmitter from '../EventEmitter';\nimport EventHandler from '../EventHandler';\nimport initializeSource from './initializeSource';\nimport decodeAudioData from './decodeAudioData';\nimport { AudioPropType, AudioEventType, AudioType } from './types';\nimport { getBuffer, preloadFile } from './utils';\n\n// if audiocontext is initialized before a user gesture on the page, its\n// state become `suspended` by default. once audiocontext.state is `suspended`\n// the only way to start it after a user gesture is executing the `resume` method\nconst start = (audioCtx: AudioContext, source: AudioBufferSourceNode) =>\n  audioCtx.state === 'suspended'\n    ? audioCtx.resume().then(() => source.start(0))\n    : source.start(0);\n\nconst Audio = ({\n  file,\n  volume = 1,\n  autoPlay = false,\n  loop = false,\n  preload = false,\n}: AudioPropType): AudioType => {\n  const audioCtx = AudioCtx();\n  const states = { ...globalStates };\n  const emitter = EventEmitter();\n  const eventHandler = EventHandler(emitter, audioCtx);\n  const curryGetBuffer = (source: AudioBufferSourceNode) => {\n    states.isDecoded = false;\n\n    getBuffer(file)\n      .then(buffer =>\n        decodeAudioData(\n          audioCtx,\n          source,\n          buffer,\n          autoPlay,\n          loop,\n          states,\n          emitter\n        )\n      )\n      .catch(console.error);\n  };\n\n  if (preload) {\n    preloadFile(file);\n  }\n\n  const Player = {\n    play() {\n      if (states.hasStarted) {\n        audioCtx.resume();\n        states.isPlaying = true;\n        return;\n      }\n\n      initializeSource(audioCtx, volume, emitter, states);\n      const { source } = states;\n\n      if (source) {\n        curryGetBuffer(source);\n\n        states.isDecoded\n          ? start(audioCtx, source)\n          : emitter.listener('decoded', () => start(audioCtx, source));\n\n        states.hasStarted = true;\n        states.isPlaying = true;\n        emitter.emit('start', { data: null });\n      }\n    },\n\n    pause() {\n      audioCtx.suspend();\n      states.isPlaying = false;\n    },\n\n    toggle() {\n      states.isPlaying ? Player.pause() : Player.play();\n    },\n\n    stop() {\n      if (states.hasStarted) {\n        states.source?.stop(0);\n        states.isPlaying = false;\n      }\n    },\n\n    on(\n      eventType: AudioEventType,\n      callback: <T>(param: { [data: string]: T }) => void\n    ) {\n      eventHandler[eventType]?.(callback);\n    },\n\n    get volume() {\n      return states.gainNode?.gain.value ?? 0;\n    },\n\n    set volume(newVolume: number) {\n      if (states.gainNode) {\n        states.gainNode.gain.value = newVolume;\n      }\n    },\n\n    get loop() {\n      return states.source?.loop ?? false;\n    },\n\n    set loop(newLoop: boolean) {\n      if (states.source) {\n        states.source.loop = newLoop;\n      }\n    },\n\n    get state() {\n      return audioCtx.state;\n    },\n\n    get audioCtx() {\n      return audioCtx;\n    },\n  };\n\n  return Player;\n};\n\nexport default Audio;\n", "import { throwsError } from './utils';\n\ndeclare global {\n  interface Window {\n    webkitAudioContext: typeof window.AudioContext;\n  }\n}\n\nconst AudioCtx = (): AudioContext => {\n  const Context = window.AudioContext || window.webkitAudioContext;\n\n  if (!Context) {\n    throwsError(\n      \"Your browser doesn't support AudioContext - https://bit.ly/2YWmpnX\"\n    );\n  }\n\n  return new Context();\n};\n\nexport default AudioCtx;\n", "import { EventEmitterType } from './EventEmitter';\n\ntype callbackType = <T>(param: { [data: string]: T }) => void;\n\ntype EventHandlerType = {\n  ready: (callback: callbackType) => void;\n  start: (callback: callbackType) => void;\n  end: (callback: callbackType) => void;\n  state: (callback: callbackType) => void;\n};\n\nconst EventHandler = (\n  emitter: EventEmitterType,\n  audioCtx?: AudioContext\n): EventHandlerType => ({\n  ready(callback: callbackType) {\n    emitter.listener('decoded', callback);\n  },\n\n  start(callback: callbackType) {\n    emitter.listener('start', callback);\n  },\n\n  end(callback: callbackType) {\n    emitter.listener('end', callback);\n  },\n\n  state(callback: callbackType) {\n    if (audioCtx) {\n      audioCtx.onstatechange = () => callback({ data: audioCtx.state });\n    }\n  },\n});\n\nexport default EventHandler;\n", "import { EventEmitterType } from '../EventEmitter';\nimport { StatesType } from './states';\n\nconst initializeSource = (\n  audioCtx: AudioContext,\n  volume: number,\n  emitter: EventEmitterType,\n  states: StatesType\n): void => {\n  const source = (states.source = audioCtx.createBufferSource());\n  const gainNode = (states.gainNode = audioCtx.createGain());\n\n  gainNode.gain.value = volume;\n  gainNode.connect(audioCtx.destination);\n  source.connect(gainNode);\n\n  source.onended = () => {\n    states.hasStarted = false;\n    states.isPlaying = false;\n    emitter.emit('end', { data: null });\n  };\n};\n\nexport default initializeSource;\n", "import { StatesType } from './states';\nimport { EventEmitterType } from '../EventEmitter';\n\nconst decodeAudioData = (\n  audioCtx: AudioContext,\n  source: AudioBufferSourceNode,\n  arrayBuffer: ArrayBuffer,\n  autoPlay: boolean,\n  loop: boolean,\n  states: StatesType,\n  emitter: EventEmitterType\n): void => {\n  const onSuccess = (buffer: AudioBuffer) => {\n    source.buffer = buffer;\n    source.loop = loop;\n\n    states.isDecoded = true;\n    emitter.emit('decoded', { data: buffer });\n\n    if (autoPlay) {\n      source.start(0);\n      states.isPlaying = true;\n    }\n  };\n\n  audioCtx.decodeAudioData(arrayBuffer, onSuccess, console.error);\n};\n\nexport default decodeAudioData;\n", "import { AudioType } from '../audio/types';\n\nexport type StatesPlaylistType = {\n  volume: number;\n  loop: boolean;\n  audio: AudioType | null;\n  isStopped: boolean;\n  isPlaying: boolean;\n  audioIndex: number;\n};\n\nconst states: StatesPlaylistType = {\n  volume: 1,\n  loop: false,\n  audio: null,\n  isStopped: false,\n  isPlaying: false,\n  audioIndex: 0,\n};\n\nexport default states;\n", "import {\n  AudioPlaylistType,\n  PlaylistPropType,\n  PlaylistEventType,\n} from './types';\n\nimport EventEmitter from '../EventEmitter';\nimport globalStates from './states';\nimport playNextAudio from './playNextAudio';\nimport playPrevAudio from './playPrevAudio';\nimport playAudio from './playAudio';\nimport { shuffle as shuffleHelper, weightedFiles, preloadFiles } from './utils';\n\nconst AudioPlaylist = ({\n  files,\n  volume = 1,\n  loop = false,\n  shuffle = false,\n  preload = false,\n  preloadLimit = 3,\n}: PlaylistPropType): AudioPlaylistType => {\n  const emmiter = EventEmitter();\n  const states = { ...globalStates, ...{ volume, loop } };\n  const hasWeights = !Array.isArray(files);\n  const shouldLoop = loop || hasWeights;\n  const normalizedFiles: string[] = hasWeights\n    ? weightedFiles(files as { [key: string]: number })\n    : (files as string[]);\n  const copiedFiles =\n    shuffle || hasWeights\n      ? shuffleHelper(normalizedFiles)\n      : normalizedFiles.slice();\n  const curryPlayAudio = playAudio(states, emmiter);\n\n  if (preload) {\n    preloadFiles(copiedFiles, preloadLimit);\n  }\n\n  const Player = {\n    play() {\n      const { audio } = states;\n      states.isPlaying = true;\n\n      if (!audio || states.isStopped) {\n        curryPlayAudio(copiedFiles, shouldLoop);\n        states.isStopped = false;\n\n        return;\n      }\n\n      audio.play();\n    },\n\n    toggle() {\n      states.isPlaying ? Player.pause() : Player.play();\n    },\n\n    pause() {\n      states.audio?.pause();\n      states.isPlaying = false;\n    },\n\n    stop() {\n      states.isPlaying = false;\n      states.isStopped = true;\n      states.audio?.stop();\n    },\n\n    next() {\n      playNextAudio(states, copiedFiles);\n    },\n\n    prev() {\n      playPrevAudio(states, copiedFiles);\n    },\n\n    on(\n      eventType: PlaylistEventType,\n      callback: (param: { [data: string]: unknown }) => void\n    ) {\n      emmiter.listener(eventType, callback);\n    },\n\n    get volume() {\n      return states.volume;\n    },\n\n    set volume(newVolume: number) {\n      states.volume = newVolume;\n\n      if (states.audio) {\n        states.audio.volume = newVolume;\n      }\n    },\n\n    get loop() {\n      return states.loop;\n    },\n\n    get audioCtx() {\n      return states.audio?.audioCtx;\n    },\n\n    set loop(newLoop: boolean) {\n      states.loop = newLoop;\n    },\n  };\n\n  return Player;\n};\n\nexport default AudioPlaylist;\n", "export const weightedFiles = (files: { [key: string]: number }): string[] => {\n  const output = [] as string[];\n  const entries = Object.entries(files);\n\n  for (const [file, weight] of entries) {\n    for (let i = 0; i < weight; i++) {\n      output.push(file);\n    }\n  }\n\n  return output;\n};\n\nexport const shuffle = (list: string[]): string[] => {\n  const result = list.slice();\n  let index = list.length - 1;\n\n  while (index >= 0) {\n    const randomIdx = Math.floor(Math.random() * index + 1);\n    const tmp = result[index];\n    result[index] = result[randomIdx];\n    result[randomIdx] = tmp;\n\n    index--;\n  }\n\n  return result;\n};\n\nexport const preloadFiles = (\n  files: string[],\n  limit: number,\n  api: (\n    input: string,\n    init?: RequestInit | undefined\n  ) => Promise<Response> = fetch,\n  done?: () => void\n): void => {\n  const queue: string[] = files.slice(limit).reverse();\n  let isDone = false;\n\n  const requestNext = () => {\n    if (!queue.length) {\n      if (!isDone) {\n        done?.();\n        isDone = true;\n      }\n    } else {\n      request(queue.pop() as string);\n    }\n  };\n\n  const request = (fileName: string) => {\n    api(fileName)\n      .then(requestNext)\n      .catch(requestNext);\n  };\n\n  for (let i = 0; i < limit; i++) {\n    request(files[i]);\n  }\n};\n", "import Audio from '../audio/Audio';\nimport { EventType, EventEmitterType } from '../EventEmitter';\nimport { StatesPlaylistType } from './states';\n\ntype playAudioType = (files: string[], loop: boolean) => void;\n\nconst playAudio = (\n  states: StatesPlaylistType,\n  emmiter: EventEmitterType\n): playAudioType => {\n  const playAudioHelper = (files: string[], loop: boolean) => {\n    const file = files[states.audioIndex];\n\n    const audio = Audio({ file, volume: states.volume });\n    states.audio = audio;\n\n    audio.on('start', e => {\n      emmiter.emit('start', e as EventType);\n    });\n\n    audio.on('end', () => {\n      if (states.isStopped) return;\n\n      if (files.length === states.audioIndex + 1) {\n        states.audio = null;\n        states.audioIndex = 0;\n\n        if (states.loop) {\n          playAudioHelper(files, loop);\n        } else {\n          emmiter.emit('end', { data: null });\n          states.isPlaying = false;\n        }\n      } else {\n        states.audioIndex++;\n        playAudioHelper(files, loop);\n      }\n    });\n\n    audio.play();\n  };\n\n  return playAudioHelper;\n};\n\nexport default playAudio;\n", "import Audio from '../audio/Audio';\nimport { StatesPlaylistType } from './states';\n\nconst playNextAudio = (states: StatesPlaylistType, files: string[]): void => {\n  const isLastFile = states.audioIndex === files.length - 1;\n  states.audioIndex = isLastFile ? 0 : states.audioIndex + 1;\n\n  states.audio?.pause();\n\n  const file = files[states.audioIndex];\n  const audio = Audio({ file, volume: states.volume });\n  states.audio = audio;\n  audio.play();\n};\n\nexport default playNextAudio;\n", "import Audio from '../audio/Audio';\nimport { StatesPlaylistType } from './states';\n\nconst playPrevAudio = (states: StatesPlaylistType, files: string[]): void => {\n  const isFirstFile = states.audioIndex === 0;\n  states.audioIndex = isFirstFile ? files.length - 1 : states.audioIndex - 1;\n\n  states.audio?.pause();\n\n  const file = files[states.audioIndex];\n  const audio = Audio({ file, volume: states.volume });\n  states.audio = audio;\n  audio.play();\n};\n\nexport default playPrevAudio;\n"],
  "mappings": "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",
  "names": ["preloadFile", "file", "attempts", "done", "fetch", "then", "catch", "states", "isDecoded", "isPlaying", "hasStarted", "source", "gainNode", "EventEmitter", "events", "listener", "keyEvent", "callback", "emit", "param", "start", "audioCtx", "state", "resume", "Audio", "volume", "autoPlay", "loop", "preload", "e", "window", "AudioContext", "webkitAudioContext", "Context", "value", "Error", "throwsError", "AudioCtx", "globalStates", "emitter", "eventHandler", "ready", "end", "onstatechange", "data", "Player", "play", "a", "createBufferSource", "createGain", "gain", "connect", "destination", "onended", "response", "ok", "status", "arrayBuffer", "buffer", "decodeAudioData", "console", "error", "pause", "suspend", "toggle", "stop", "on", "eventType", "newVolume", "newLoop", "audio", "isStopped", "audioIndex", "files", "shuffle", "preloadLimit", "emmiter", "hasWeights", "Array", "isArray", "shouldLoop", "normalizedFiles", "output", "entries", "Object", "weight", "i", "push", "copiedFiles", "list", "result", "slice", "index", "length", "randomIdx", "Math", "floor", "random", "tmp", "curryPlayAudio", "t", "playAudioHelper", "limit", "api", "queue", "reverse", "isDone", "requestNext", "request", "pop", "fileName", "next", "prev"]
}
